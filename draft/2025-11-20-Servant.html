<!DOCTYPE html>
<html lang="en">
  <head>
        <title>All about Servant</title>
    <meta charset="utf-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1">        
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="/includes/css/proofs.css" />
    <link rel="stylesheet" href="/includes/css/tables.css" />
  </head>
  <body>

    <!-- Wrap all page content here -->
    <div id="wrap" ng-app="HomePageApp">

      <!-- Fixed navbar -->
      <div class="navbar navbar-inverse" role="navigation">
        <div class="container-fluid" id="navfluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navigationbar">
               <span class="sr-only">Toggle navigation</span>
               <span class="icon-bar"></span>
               <span class="icon-bar"></span>
               <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">hde.design</a>
          </div>
	  <div>
            <div class="collapse navbar-collapse" id="navigationbar">
              <ul class="nav navbar-nav">
                <li><a href="https://heades.github.io">Author</a></li>
                <li><a href="/">Posts</a></li>                
            </ul>
            </div>
          </div><!--/.nav-collapse -->
        </div>
      </div>

      <!-- Begin page content -->
      <div class="container">
        <div class="well">
          <h2>All about Servant</h2>
              Updated: 2025-11-29
        </div>
	<div class="row">
	  <div class="col-md-2">
	  </div>
	  <div class="col-md-10" style="font-size:20px;">
<div id="divCheckbox" style="display: none;">
  <span class="math display">
    \[    
    \newcommand{\ottnt}[1]{#1}
    \newcommand{\ottsym}[1]{#1}
    \newcommand{\ottmv}[1]{\mathit{#1}}

    \newcommand{\func}[1]{\mathsf{#1}}
    \newcommand{\Lin}[0]{\func{Lin}}
    \newcommand{\Mny}[0]{\func{Mny}}
    \newcommand{\Forget}[0]{\func{Forget}}
    \newcommand{\Free}[0]{\func{Free}}
    \newcommand{\Endo}[0]{\func{Endo}}
    \newcommand{\mto}[1]{\xrightarrow{#1}}
    \newcommand{\interp}[1]{[\negthinspace[#1]\negthinspace]}

    \newcommand{\cat}[1]{\mathcal{#1}}
    \newcommand{\catobj}[1]{\mathsf{Obj}(\cat{#1})}
    \newcommand{\Obj}[1]{\catobj{#1}}
    \newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
    \newcommand{\sets}[0]{\mathsf{Set}}
    \newcommand{\Set}[0]{\sets}
    \newcommand{\mor}[1]{\mathsf{Mor}(\cat{#1})}
    \newcommand{\Hom}[3]{\mathsf{Hom}_{#1}(#2,#3)}
    \newcommand{\cur}[0]{\mathsf{cur}}
    \newcommand{\curi}[0]{\mathsf{cur}^{-1}}
    \newcommand{\app}[0]{\mathsf{app}}
    \newcommand{\id}[0]{\mathsf{id}}
    \newcommand{\injl}[0]{\mathsf{inj_l}}
    \newcommand{\injr}[0]{\mathsf{inj_r}}
    \newcommand{\pow}[1]{\mathcal{P}(#1)}

    \newcommand{\oast}{&circledast;}
    \]
  </span>
</div>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Contents</h2>
<ul>
<li><a href="#setup" id="toc-setup">Setup</a></li>
<li><a href="#a-simple-api" id="toc-a-simple-api">A Simple API</a>
<ul>
<li><a href="#the-database" id="toc-the-database">The Database</a></li>
<li><a href="#query-resolution" id="toc-query-resolution">Query
Resolution</a></li>
<li><a href="#executing-a-query" id="toc-executing-a-query">Executing a
query</a></li>
</ul></li>
<li><a href="#authorization-tba"
id="toc-authorization-tba">Authorization (TBA)</a></li>
</ul>
</nav>

<main>
  <p><strong>I’m live writing this, and so this document is ALIVE
  (ALIVE, IT’S ALIVE), so expect there to be errors, gaps, and no ending
  (yet).</strong></p>
  <p>Servant is a Haskell library for writing web API’s. Some research
  I’m starting up requires that I understand how it works. So I thought
  I’d write up my notes here. These notes simply follow along with the
  <a href="https://docs.servant.dev/en/latest/index.html">Servant
  Documentation</a>.</p>
  <h1 id="setup">Setup</h1>
  <p>I’m using Docker Compose with two services: a service called
  <code>servant</code> and a service called <code>database</code>. The
  latter is the default Postgres image from DockerHub, but I wrote a
  custom <code>init.db</code> script that populates it with a schema and
  dataset of random information from the Mega Man video game. I’ll use
  this data to write queries that will modify and read an actual
  database.</p>
  <p>The <a href="https://docs.servant.dev/en/latest/index.html">Servant
  Documentation</a> does mention that there is a Stack template, but I
  wanted to start from scratch to better understand everything. I simply
  created a new stack project with <code>stack --init</code> with the
  bare template.</p>
  <h1 id="a-simple-api">A Simple API</h1>
  <p>We will start with a simple query that does no filtering. Looks
  like they recommend that we put our API into it’s own Haskell module.
  I created a new module called <code>WebAPIType</code> which will
  contain the web API. Servant’s whole bag is the specification of the
  API at the type level. So this module will contain that type or
  several types. Since we are working at the type level it makes sense
  that we need language extensions:</p>
  <pre class=".haskell"><code>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}</code></pre>
  <p>I’ll start by creating a single query for pulling all the Mega Man
  games which has the following schema:</p>
  <div class="sourceCode" id="cb2"><pre
  class="sourceCode .sql"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="cf">IF</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span> games (</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  game_id           BIGSERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  slug              TEXT <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">UNIQUE</span> <span class="kw">CHECK</span> (is_valid_slug(slug)),</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  title             TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  series_number     <span class="dt">SMALLINT</span> <span class="kw">CHECK</span> (series_number <span class="op">&gt;</span> <span class="dv">0</span>),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  release_date      <span class="dt">DATE</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  platform          TEXT,               <span class="co">-- e.g., &quot;NES&quot;, &quot;SNES&quot;, &quot;PS4&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  created_at        TIMESTAMPTZ <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> NOW(),</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  updated_at        TIMESTAMPTZ <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> NOW()</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
  <p>We can define the <code>Game</code> record as follows:</p>
  <pre class=".haskell"><code>type Date = UTCTime

data Game = Game {
    title :: Text,
    seriesNumber :: Integer,
    releaseDate :: Date,
    platform :: Text
}</code></pre>
  <p>This can easily be encoded and decoded from JSON which Servant
  takes care of for us. Since we are using <code>Text</code> and
  <code>UTCTime</code> we also need the following imports:</p>
  <pre class=".haskell"><code>import Servant.API
import Data.Time (UTCTime)
import Data.Text (Text)</code></pre>
  <p>Now using the <code>Game</code> record we define the
  <code>GameAPI</code> type as follows:</p>
  <pre class=".haskell"><code>type GameAPI = &quot;games&quot; :&gt; Get &#39;[JSON] [Game]</code></pre>
  <p>Let’s break this type’s definition down:</p>
  <ul>
  <li><p><code>"games"</code> is the name of our query.</p></li>
  <li><p><code>:&gt;</code> is a Servant operator that we use to create
  path in our API queries. We can think of <code>:&gt;</code> as simply
  <code>/</code> where the last element in the chain of
  <code>:&gt;</code>’s is the operation at that path. So
  <code>"games" :&gt; Get '[JSON] [Game]</code> is equivalent to the
  path <code>/games</code> and it performs a <code>Get</code>, but if I
  did
  <code>"seg1" :&gt; "seg2" :&gt; "seg3" :&gt; Get '[JSON] [b]</code>
  then we obtain a path <code>/seg1/seg2/se3</code> which will perform a
  <code>Get</code>.</p></li>
  <li><p><code>Get a b</code> describes the type of request being made
  at the path we describe using <code>:&gt;</code>. This is a GET
  request and it’ll return a <code>b</code> encoded as an
  <code>a</code>. So if <code>a</code> is <code>'[JSON]</code>, then
  <code>b</code> is encoded as a JSON response using <a
  href="https://hackage.haskell.org/package/aeson">Aeson</a>.</p>
  <p>Next we need to actually serve the API. We’ll create a new module
  called <code>Server</code> for this. First, we import the
  <code>WebAPI</code>:</p>
  <pre class=".haskell"><code>import WebAPIType (GameAPI, Game)</code></pre></li>
  </ul>
  <p>Then from Servant we will need the following:</p>
  <pre class=".haskell"><code>import Servant (Server, Application, Proxy(..), serve)</code></pre>
  <p><code>Server</code> is the type of the server that we will create
  from our API <code>GameAPI</code>. It is here that we connect the API
  to our server-side resolver (Servant calls these handlers). It has the
  following definition:</p>
  <pre class=".haskell"><code>class HasServer api context where
  type ServerT api (m :: Type -&gt; Type) :: Type

  route ::
       Proxy api
    -&gt; Context context
    -&gt; Delayed env (Server api)
    -&gt; Router env

  hoistServerWithContext
      :: Proxy api
      -&gt; Proxy context
      -&gt; (forall x. m x -&gt; n x)
      -&gt; ServerT api m
      -&gt; ServerT api n

type Server api = ServerT api Handler</code></pre>
  <p>This is a cool way to define the <code>Server</code> type, using a
  type class, because now Servant can create different instances based
  on how the API is defined. For example, if one of your endpoints in
  your API route requires input, then Servant will require your resolver
  to be a function where the input is this input to the route. We will
  see some examples of this later.</p>
  <p>The <code>Proxy</code> type is used to create a witness to all our
  type-level magic. We give the proxied API to the <code>serve</code>
  command when we create our final Servant <code>Application</code>.
  This application can then be given to the Wai Warp server which allows
  us to actually serve our API on a port of our system.</p>
  <p>The <code>GameAPI</code> can now be turned into something servable
  using the above:</p>
  <pre class=".haskell"><code>games :: [Game]
games = []

serverGames :: Server GameAPI
serverGames = return games

-- Actually build the api:
gamesAPI :: Proxy GameAPI
gamesAPI = Proxy

gamesApp :: Application
gamesApp = serve gamesAPI serverGames</code></pre>
  <p>One question I currently have is, can <code>games</code> exist in
  the IO monad? I’ll need to query the database which will need to be in
  IO.</p>
  <p>Finally, we can serve our API using the following:</p>
  <pre class=".haskell"><code>module Main (main) where

import Server (gamesApp)

import Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 5000 gamesApp</code></pre>
  <p>Let’s try and get this connected to the database using the <a
  href="https://hackage.haskell.org/package/hasql">HASQL
  Library</a>.</p>
  <h2 id="the-database">The Database</h2>
  <p><a href="https://hackage.haskell.org/package/hasql">HASQL
  Library</a> appears to be the best option for connecting to Postgres
  that is production grade. In this section we will setup HASQL within
  our example Servant application. This will allow us to conduct more
  realistic experiments to help our understanding.</p>
  <p>Getting HASQL installed was a little bit of a challenge, because I
  didn’t want to install the full Postgres database in the container of
  our example API, because it runs in a separate container as its own
  service. So I just want to connect to it using HASQL as a client. This
  requires the following packages be installed in the API’s
  container:</p>
  <pre><code>- libpq-dev
- postgresql-client</code></pre>
  <p>These got HASQL to fully install as part of our project. I also
  needed to add the following dependencies to my
  <code>stack.yaml</code>’s <code>extra-deps</code>:</p>
  <pre><code>- testcontainers
- testcontainers-postgresql
- text-builder-core
- text-builder</code></pre>
  <p>HASQL wouldn’t compile without them. Now that I have a working
  build we can proceed with setting up HASQL to query my database. I
  created a new module <code>Database</code> to house all of our
  database specific code.</p>
  <p>First, we have to establish a connection with the database. Based
  on the documentation we should use these:</p>
  <pre class=".haskell"><code>Hasql.Connection
Hasql.Connection.Setting
Hasql.Connection.Setting.Connection</code></pre>
  <p>I setup a database settings record:</p>
  <pre class=".haskell"><code>data ConnectionSettings = ConnectionSettings {
    ipAddr :: String,
    port :: Int,
    user :: String,
    dbname :: String
}

settings :: ConnectionSettings
settings = ConnectionSettings {
    ipAddr = &quot;123.4.5.6&quot;,
    port = 5432,
    user = &quot;postgres&quot;,
    dbname = &quot;postgres&quot;
}</code></pre>
  <p>Then we can establish a connection to the database using
  <code>Connection.acquire :: [Setting] -&gt; IO (Either ConnectionError Connection)</code>
  where we first define a <code>Setting</code> as a Postgres connection
  string:</p>
  <pre class=".haskell"><code>psqlSettings :: T.Text
psqlSettings = T.pack $ &quot;host=&quot;++settings.ipAddr++&quot; dbname=&quot;++settings.dbname++&quot; user=&quot;++settings.user++&quot; port=&quot;++(show settings.port)

connect :: IO (Either Connection.ConnectionError Connection.Connection)
connect = Connection.acquire [connectSettings]
    where
        connectSettings = ConnectionSetting.connection $ ConnectionSettingConnection.string psqlSettings</code></pre>
  <p>Updating the main loop to make a connection to the database is
  pretty easy now:</p>
  <pre class=".haskell"><code>main :: IO ()
main = do
    _dbconn &lt;- connect
    case _dbconn of
        Left err -&gt; putStrLn . show $ err
        Right dbconn -&gt; do putStrLn &quot;Connected to Postgres&quot;
                          hFlush stdout
                          -- Make use of dbconn.
                          run 5000 gamesApp</code></pre>
  <p>In order to pass the database connection to <code>gamesApp</code>,
  we modify the type of <code>gamesApp</code> placing it into the
  <code>Control.Monad.Reader</code> monad.</p>
  <pre class=".haskell"><code>gamesApp :: Reader Connection Application
gamesApp = do
    sg &lt;- serverGames
    return $ serve gamesAPI sg</code></pre>
  <p>Since the resolution of the query happens in
  <code>serverGames</code> we update it as well:</p>
  <pre class=".haskell"><code>serverGames :: Reader Connection (Server GameAPI)
serverGames = do
    dbconn &lt;- ask
    return . liftIO $ games dbconn</code></pre>
  <p>The type of <code>gamesProxy</code> doesn’t need to change, because
  it does’nt need to access the database. However, <code>games</code> is
  the resolution function, and hence does need access to the database,
  but we update it as a pure function:</p>
  <pre class=".haskell"><code>games :: Connection -&gt; IO [Game]
games dbconn = return []</code></pre>
  <p>We now have access to the database in the resolution function for
  the <code>games</code> query. So the next step is to actually write an
  SQL query for all of the games in the database, and execute the query
  on the database using <code>dbconn</code>.</p>
  <p>Querying the database requires us to define two things: a
  <code>Statement</code> and a <code>Session</code>. The former boils
  down to the actual Postgres query while the latter is the action,
  synthesized from the statement, to be executed on the database
  connection. Then we simply pass the database connection and the
  session to the <code>run</code> function and the query will be
  executed on the database.</p>
  <p>These both require encoding/decoding of the data to/from the
  database and Haskell. I defined the encoding between <code>Game</code>
  and Postgres as follows:</p>
  <pre class=".haskell"><code>gameParams :: HEnc.Params Game
gameParams = (title &gt;$&lt; HEnc.param (HEnc.nonNullable HEnc.text))
          &lt;&gt; (fmap fromInteger . seriesNumber &gt;$&lt; HEnc.param (HEnc.nullable HEnc.int8))
          &lt;&gt; (releaseDate &gt;$&lt; HEnc.param (HEnc.nullable HEnc.timestamptz))
          &lt;&gt; (platform &gt;$&lt; HEnc.param (HEnc.nullable HEnc.text))</code></pre>
  <p>This encoder allows for the <code>Game</code> record to be given as
  a parameter to an SQL statement. Each field of <code>Game</code> needs
  it’s own encoding using
  <code>param :: NullableOrNot Value a -&gt; Params a</code> that takes
  as input an encoder between a Postgres value that can be nullable or
  not and a Haskell type. We compose this encoder with the projection
  function of the field we are encoding. For example,</p>
  <pre class=".haskell"><code>fmap fromInteger . seriesNumber &gt;$&lt; HEnc.param (HEnc.nullable HEnc.int8)</code></pre>
  <p>This encoder of the <code>seriesNumber</code> field, first projects
  the series number, then converts it into an <code>Int64</code> which
  is then encoded as a parameter into Postgres. We need the call to
  <code>fmap</code>, because the series number is nullable, hence the
  type of <code>seriesNumber</code> is <code>Maybe Integer</code> and we
  need a <code>Maybe Int64</code> which is encodable into Postgres.</p>
  <p>Decoding is opposite, but operates at the row level of the returned
  data from the database. Ultimately, we wish to query for the list of
  all <code>Game</code>’s which corresponds to a list of games
  <code>[Game]</code>. Decoding a list of games is easy if we can decode
  single row containing a <code>Game</code>. We do this as follows:</p>
  <pre class=".haskell"><code>gameRow :: HDec.Row Game
gameRow = Game &lt;$&gt; HDec.column (HDec.nonNullable HDec.text)               -- title
               &lt;*&gt; HDec.column (HDec.nullable (fmap toInteger HDec.int8)) -- seriesNumber
               &lt;*&gt; HDec.column (HDec.nullable HDec.timestamptz)           -- releaseDate
               &lt;*&gt; HDec.column (HDec.nullable HDec.text)                  -- platform</code></pre>
  <p>Here <code>gameRow</code> returns <code>Game</code> record by
  decoding each column of the row. The title of the game is decoded
  as:</p>
  <pre class=".haskell"><code>HDec.column (HDec.nonNullable HDec.text) -- title</code></pre>
  <p>This says, decode this column as a <code>Text</code> value that is
  non-nullable. Thus, the above code has the type <code>Row Text</code>
  whereas the following:</p>
  <pre class=".haskell"><code>HDec.column (HDec.nullable (fmap toInteger HDec.int8)) -- seriesNumber</code></pre>
  <p>has type <code>Row (Maybe Integer)</code>, because the series
  number is nullable.</p>
  <p>Next we use this decoder to decode lists of <code>Games</code>:</p>
  <pre class=".haskell"><code>gamesDecoder :: HDec.Result [Game]
gamesDecoder = HDec.rowList gameRow</code></pre>
  <p>We use the library function
  <code>rowList :: Row a -&gt; Result [a]</code> to lift our
  <code>Game</code> decoder to lists. At this point we have everything
  we need to be able to resolve queries using the database.</p>
  <h2 id="query-resolution">Query Resolution</h2>
  <p>In the previous section we finished with needing to define a
  <code>Statement</code> and a <code>Session</code> in order to execute
  a query on the database. These are both coupled tightly to the actual
  query being resolved by Servant; and thus, we define these as part of
  the resolver for our <code>games</code> query in the module
  <code>Resolver</code>. The actual SQL statement we wish to execute is
  defined as a Hasql <code>Statement</code>:</p>
  <pre class=".haskell"><code>selectGames :: Statement () [Game]
selectGames = Statement sql HEnc.noParams gamesDecoder True
    where
        sql = &quot;select title, series_number, release_date, platform from games&quot;</code></pre>
  <p>The <code>selectGames</code> statement simply configures Hasql for
  parsing the SQL statement <code>sql</code>. This statement has no
  parameters indicated by using <code>noParams</code>, Hasql should
  decode the returned data using the <code>gamesDecoder</code> defined
  in the previous section, and finally, Hasql should execute this as a
  single query indicated by <code>True</code> which should improve
  performance (based on the Hasql documentation).</p>
  <p>Using <code>selectGames</code> we can define our Hasql
  <code>Session</code>:</p>
  <pre class=".haskell"><code>gamesSession :: Session [Game]
gamesSession = statement () selectGames</code></pre>
  <p>Since we have no parameters we give
  <code>statement :: params -&gt; Statement params result -&gt; Session result</code>
  the unit <code>()</code>, but give <code>selectGames</code> as our
  result.</p>
  <p>Now we can use <code>gamesSession</code> to define our resolver for
  our <code>games</code> Servant query:</p>
  <pre class=".haskell"><code>games :: Connection -&gt; IO [Game]
games dbconn = do
    result &lt;- run gamesSession dbconn
    case result of
        Left err -&gt; error . show $ err
        Right g -&gt; do print g
                      hFlush stdout
                      return g</code></pre>
  <p>We first run the <code>gamesSession</code> on the database using
  the given connection <code>dbconn</code>, and then simply case split
  on the result to determine if we got an error or a value result.</p>
  <h2 id="executing-a-query">Executing a query</h2>
  <p>We can now execute our <code>games</code> query to obtain the list
  of games:</p>
  <div class="sourceCode" id="cb29"><pre
  class="sourceCode .bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># curl http://localhost:5000/games</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ex">[</span><span class="dt">{</span><span class="st">&quot;platform&quot;</span><span class="dt">:</span><span class="st">&quot;NES&quot;</span><span class="op">,</span><span class="st">&quot;releaseDate&quot;</span><span class="dt">:</span><span class="st">&quot;2000-01-01T01:11:34.962898Z&quot;</span><span class="op">,</span><span class="st">&quot;seriesNumber&quot;</span><span class="dt">:1</span><span class="op">,</span><span class="st">&quot;title&quot;</span><span class="dt">:</span><span class="st">&quot;Mega Man&quot;</span><span class="dt">}</span><span class="ex">,</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">{</span><span class="st">&quot;platform&quot;</span><span class="dt">:</span><span class="st">&quot;NES&quot;</span><span class="op">,</span><span class="st">&quot;releaseDate&quot;</span><span class="dt">:</span><span class="st">&quot;2000-01-01T01:11:34.963271Z&quot;</span><span class="op">,</span><span class="st">&quot;seriesNumber&quot;</span><span class="dt">:2</span><span class="op">,</span><span class="st">&quot;title&quot;</span><span class="dt">:</span><span class="st">&quot;Mega Man 2&quot;</span><span class="dt">}</span><span class="ex">,</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">{</span><span class="st">&quot;platform&quot;</span><span class="dt">:</span><span class="st">&quot;NES&quot;</span><span class="op">,</span><span class="st">&quot;releaseDate&quot;</span><span class="dt">:</span><span class="st">&quot;2000-01-01T01:11:34.963914Z&quot;</span><span class="op">,</span><span class="st">&quot;seriesNumber&quot;</span><span class="dt">:3</span><span class="op">,</span><span class="st">&quot;title&quot;</span><span class="dt">:</span><span class="st">&quot;Mega Man 3&quot;</span><span class="dt">}</span><span class="ex">,</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">{</span><span class="st">&quot;platform&quot;</span><span class="dt">:</span><span class="st">&quot;SNES&quot;</span><span class="op">,</span><span class="st">&quot;releaseDate&quot;</span><span class="dt">:</span><span class="st">&quot;2000-01-01T01:11:34.96509Z&quot;</span><span class="op">,</span><span class="st">&quot;seriesNumber&quot;</span><span class="dt">:1</span><span class="op">,</span><span class="st">&quot;title&quot;</span><span class="dt">:</span><span class="st">&quot;Mega Man X&quot;</span><span class="dt">}</span><span class="ex">,</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">{</span><span class="st">&quot;platform&quot;</span><span class="dt">:</span><span class="st">&quot;PS4&quot;</span><span class="op">,</span><span class="st">&quot;releaseDate&quot;</span><span class="dt">:</span><span class="st">&quot;2000-01-01T00:00:00.006849Z&quot;</span><span class="op">,</span><span class="st">&quot;seriesNumber&quot;</span><span class="dt">:11</span><span class="op">,</span><span class="st">&quot;title&quot;</span><span class="dt">:</span><span class="st">&quot;Mega Man 11&quot;</span><span class="dt">}</span><span class="ex">]</span></span></code></pre></div>
  <p>As we can see all of the games in our database are returned.</p>
  <p>To be continued….</p>
  <h1 id="authorization-tba">Authorization (TBA)</h1>
  <p>Authorization uses <a
  href="https://en.wikipedia.org/wiki/Basic_access_authentication">Basic
  Auth</a></p>
</main>
            <hr>
            <p>
                        <em>Leave a comment by sending me an <a href="mailto:harley.eades@gmail.com">Email</a></em>
                        </p>
	  <div class="col-md-1">
	  </div>
	</div>
      </div>
    </div>

    <div id="footer">
      <div class="container">
	<p class="text-right" class="text-muted credit">	
	</p>
      </div>
    </div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
     <script>
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

       ga('create', 'UA-71081670-1', 'auto');
       ga('send', 'pageview');
     </script>
  </body>
</html>
