<!DOCTYPE html>
<html lang="en">
  <head>
        <title>All about Servant</title>
    <meta charset="utf-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1">        
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="/includes/css/proofs.css" />
    <link rel="stylesheet" href="/includes/css/tables.css" />
  </head>
  <body>

    <!-- Wrap all page content here -->
    <div id="wrap" ng-app="HomePageApp">

      <!-- Fixed navbar -->
      <div class="navbar navbar-inverse" role="navigation">
        <div class="container-fluid" id="navfluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navigationbar">
               <span class="sr-only">Toggle navigation</span>
               <span class="icon-bar"></span>
               <span class="icon-bar"></span>
               <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">hde.design</a>
          </div>
	  <div>
            <div class="collapse navbar-collapse" id="navigationbar">
              <ul class="nav navbar-nav">
                <li><a href="https://heades.github.io">Author</a></li>
                <li><a href="/">Posts</a></li>                
            </ul>
            </div>
          </div><!--/.nav-collapse -->
        </div>
      </div>

      <!-- Begin page content -->
      <div class="container">
        <div class="well">
          <h2>All about Servant</h2>
              Updated: 2025-11-25
        </div>
	<div class="row">
	  <div class="col-md-2">
	  </div>
	  <div class="col-md-10" style="font-size:20px;">
<div id="divCheckbox" style="display: none;">
  <span class="math display">
    \[    
    \newcommand{\ottnt}[1]{#1}
    \newcommand{\ottsym}[1]{#1}
    \newcommand{\ottmv}[1]{\mathit{#1}}

    \newcommand{\func}[1]{\mathsf{#1}}
    \newcommand{\Lin}[0]{\func{Lin}}
    \newcommand{\Mny}[0]{\func{Mny}}
    \newcommand{\Forget}[0]{\func{Forget}}
    \newcommand{\Free}[0]{\func{Free}}
    \newcommand{\Endo}[0]{\func{Endo}}
    \newcommand{\mto}[1]{\xrightarrow{#1}}
    \newcommand{\interp}[1]{[\negthinspace[#1]\negthinspace]}

    \newcommand{\cat}[1]{\mathcal{#1}}
    \newcommand{\catobj}[1]{\mathsf{Obj}(\cat{#1})}
    \newcommand{\Obj}[1]{\catobj{#1}}
    \newcommand{\catop}[1]{\cat{#1}^{\mathsf{op}}}
    \newcommand{\sets}[0]{\mathsf{Set}}
    \newcommand{\Set}[0]{\sets}
    \newcommand{\mor}[1]{\mathsf{Mor}(\cat{#1})}
    \newcommand{\Hom}[3]{\mathsf{Hom}_{#1}(#2,#3)}
    \newcommand{\cur}[0]{\mathsf{cur}}
    \newcommand{\curi}[0]{\mathsf{cur}^{-1}}
    \newcommand{\app}[0]{\mathsf{app}}
    \newcommand{\id}[0]{\mathsf{id}}
    \newcommand{\injl}[0]{\mathsf{inj_l}}
    \newcommand{\injr}[0]{\mathsf{inj_r}}
    \newcommand{\pow}[1]{\mathcal{P}(#1)}

    \newcommand{\oast}{&circledast;}
    \]
  </span>
</div>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Contents</h2>
<ul>
<li><a href="#setup" id="toc-setup">Setup</a></li>
<li><a href="#a-simple-api" id="toc-a-simple-api">A Simple API</a>
<ul>
<li><a href="#the-database" id="toc-the-database">The Database</a></li>
</ul></li>
</ul>
</nav>

<main>
  <p><strong>I’m live writing this, and so this document is ALIVE
  (ALIVE, IT’S ALIVE), so expect there to be errors, gaps, and no ending
  (yet).</strong></p>
  <p>Servant is a Haskell library for writing web API’s. Some research
  I’m starting up requires that I understand how it works. So I thought
  I’d write up my notes here. These notes simply follow along with the
  <a href="https://docs.servant.dev/en/latest/index.html">Servant
  Documentation</a>.</p>
  <h1 id="setup">Setup</h1>
  <p>I’m using Docker Compose with two services: a service called
  <code>servant</code> and a service called <code>database</code>. The
  latter is the default Postgres image from DockerHub, but I wrote a
  custom <code>init.db</code> script that populates it with a schema and
  dataset of random information from the Mega Man video game. I’ll use
  this data to write queries that will modify and read an actual
  database.</p>
  <p>The <a href="https://docs.servant.dev/en/latest/index.html">Servant
  Documentation</a> does mention that there is a Stack template, but I
  wanted to start from scratch to better understand everything. I simply
  created a new stack project with <code>stack --init</code> with the
  bare template.</p>
  <h1 id="a-simple-api">A Simple API</h1>
  <p>We will start with a simple query that does no filtering. Looks
  like they recommend that we put our API into it’s own Haskell module.
  I created a new module called <code>WebAPIType</code> which will
  contain the web API. Servant’s whole bag is the specification of the
  API at the type level. So this module will contain that type or
  several types. Since we are working at the type level it makes sense
  that we need language extensions:</p>
  <pre class=".haskell"><code>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}</code></pre>
  <p>I’ll start by creating a single query for pulling all the Mega Man
  games which has the following schema:</p>
  <div class="sourceCode" id="cb2"><pre
  class="sourceCode .sql"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="cf">IF</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span> games (</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  game_id           BIGSERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  slug              TEXT <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">UNIQUE</span> <span class="kw">CHECK</span> (is_valid_slug(slug)),</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  title             TEXT <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  series_number     <span class="dt">SMALLINT</span> <span class="kw">CHECK</span> (series_number <span class="op">&gt;</span> <span class="dv">0</span>),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  release_date      <span class="dt">DATE</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  platform          TEXT,               <span class="co">-- e.g., &quot;NES&quot;, &quot;SNES&quot;, &quot;PS4&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  created_at        TIMESTAMPTZ <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> NOW(),</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  updated_at        TIMESTAMPTZ <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">DEFAULT</span> NOW()</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
  <p>We can define the <code>Game</code> record as follows:</p>
  <pre class=".haskell"><code>type Date = UTCTime

data Game = Game {
    title :: Text,
    seriesNumber :: Integer,
    releaseDate :: Date,
    platform :: Text
}</code></pre>
  <p>This can easily be encoded and decoded from JSON which Servant
  takes care of for us. Since we are using <code>Text</code> and
  <code>UTCTime</code> we also need the following imports:</p>
  <pre class=".haskell"><code>import Servant.API
import Data.Time (UTCTime)
import Data.Text (Text)</code></pre>
  <p>Now using the <code>Game</code> record we define the
  <code>GameAPI</code> type as follows:</p>
  <pre class=".haskell"><code>type GameAPI = &quot;games&quot; :&gt; Get &#39;[JSON] [Game]</code></pre>
  <p>Let’s break this type’s definition down:</p>
  <ul>
  <li><p><code>"games"</code> is the name of our query.</p></li>
  <li><p><code>:&gt;</code> is a Servant operator that we use to create
  path in our API queries. We can think of <code>:&gt;</code> as simply
  <code>/</code> where the last element in the chain of
  <code>:&gt;</code>’s is the operation at that path. So
  <code>"games" :&gt; Get '[JSON] [Game]</code> is equivalent to the
  path <code>/games</code> and it performs a <code>Get</code>, but if I
  did
  <code>"seg1" :&gt; "seg2" :&gt; "seg3" :&gt; Get '[JSON] [b]</code>
  then we obtain a path <code>/seg1/seg2/se3</code> which will perform a
  <code>Get</code>.</p></li>
  <li><p><code>Get a b</code> describes the type of request being made
  at the path we describe using <code>:&gt;</code>. This is a GET
  request and it’ll return a <code>b</code> encoded as an
  <code>a</code>. So if <code>a</code> is <code>'[JSON]</code>, then
  <code>b</code> is encoded as a JSON response using <a
  href="https://hackage.haskell.org/package/aeson">Aeson</a>.</p>
  <p>Next we need to actually serve the API. We’ll create a new module
  called <code>Server</code> for this. First, we import the
  <code>WebAPI</code>:</p>
  <pre class=".haskell"><code>import WebAPIType (GameAPI, Game)</code></pre></li>
  </ul>
  <p>Then from Servant we will need the following:</p>
  <pre class=".haskell"><code>import Servant (Server, Application, Proxy(..), serve)</code></pre>
  <p><code>Server</code> is the type of the server that we will create
  from our API <code>GameAPI</code>. It is here that we connect the API
  to our server-side resolver (Servant calls these handlers). It has the
  following definition:</p>
  <pre class=".haskell"><code>class HasServer api context where
  type ServerT api (m :: Type -&gt; Type) :: Type

  route ::
       Proxy api
    -&gt; Context context
    -&gt; Delayed env (Server api)
    -&gt; Router env

  hoistServerWithContext
      :: Proxy api
      -&gt; Proxy context
      -&gt; (forall x. m x -&gt; n x)
      -&gt; ServerT api m
      -&gt; ServerT api n

type Server api = ServerT api Handler</code></pre>
  <p>This is a cool way to define the <code>Server</code> type, using a
  type class, because now Servant can create different instances based
  on how the API is defined. For example, if one of your endpoints in
  your API route requires input, then Servant will require your resolver
  to be a function where the input is this input to the route. We will
  see some examples of this later.</p>
  <p>The <code>Proxy</code> type is used to create a witness to all our
  type-level magic. We give the proxied API to the <code>serve</code>
  command when we create our final Servant <code>Application</code>.
  This application can then be given to the Wai Warp server which allows
  us to actually serve our API on a port of our system.</p>
  <p>The <code>GameAPI</code> can now be turned into something servable
  using the above:</p>
  <pre class=".haskell"><code>games :: [Game]
games = []

serverGames :: Server GameAPI
serverGames = return games

-- Actually build the api:
gamesAPI :: Proxy GameAPI
gamesAPI = Proxy

gamesApp :: Application
gamesApp = serve gamesAPI serverGames</code></pre>
  <p>One question I currently have is, can <code>games</code> exist in
  the IO monad? I’ll need to query the database which will need to be in
  IO.</p>
  <p>Finally, we can serve our API using the following:</p>
  <pre class=".haskell"><code>module Main (main) where

import Server (gamesApp)

import Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 5000 gamesApp</code></pre>
  <p>Let’s try and get this connected to the database using the <a
  href="https://hackage.haskell.org/package/hasql">HASQL
  Library</a>.</p>
  <h2 id="the-database">The Database</h2>
  <p><a href="https://hackage.haskell.org/package/hasql">HASQL
  Library</a> appears to be the best option for connecting to Postgres
  that is production grade. In this section we will setup HASQL within
  our example Servant application. This will allow us to conduct more
  realistic experiments to help our understanding.</p>
  <p>Getting HASQL installed was a little bit of a challenge, because I
  didn’t want to install the full Postgres database in the container of
  our example API, because it runs in a separate container as its own
  service. So I just want to connect to it using HASQL as a client. This
  requires the following packages be installed in the API’s
  container:</p>
  <pre><code>- libpq-dev
- postgresql-client</code></pre>
  <p>These got HASQL to fully install as part of our project. I also
  needed to add the following dependencies to my
  <code>stack.yaml</code>’s <code>extra-deps</code>:</p>
  <pre><code>- testcontainers
- testcontainers-postgresql
- text-builder-core
- text-builder</code></pre>
  <p>HASQL wouldn’t compile without them. Now that I have a working
  build we can proceed with setting up HASQL to query my database. I
  created a new module <code>Database</code> to house all of our
  database specific code.</p>
  <p>First, we have to establish a connection with the database. Based
  on the documentation we should use these:</p>
  <pre class=".haskell"><code>Hasql.Connection
Hasql.Connection.Setting
Hasql.Connection.Setting.Connection</code></pre>
  <p>Authorization uses <a
  href="https://en.wikipedia.org/wiki/Basic_access_authentication">Basic
  Auth</a></p>
  <p>To be continued….</p>
</main>
            <hr>
            <p>
                        <em>Leave a comment by sending me an <a href="mailto:harley.eades@gmail.com">Email</a></em>
                        </p>
	  <div class="col-md-1">
	  </div>
	</div>
      </div>
    </div>

    <div id="footer">
      <div class="container">
	<p class="text-right" class="text-muted credit">	
	</p>
      </div>
    </div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
     <script>
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

       ga('create', 'UA-71081670-1', 'auto');
       ga('send', 'pageview');
     </script>
  </body>
</html>
