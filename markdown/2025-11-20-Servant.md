---
title: 'All about Servant'
date: 2025-11-25
categories:
  - haskell
  - web api
  - servant
  - web development
abstract: "Notes on how servant works."
toc: true
---

**I'm live writing this, and so this document is ALIVE (ALIVE, IT'S ALIVE), so
expect there to be errors, gaps, and no ending (yet).**

Servant is a Haskell library for writing web API's. Some research I'm starting
up requires that I understand how it works. So I thought I'd write up my notes
here. These notes simply follow along with the 
[Servant Documentation](https://docs.servant.dev/en/latest/index.html).

# Setup

I'm using Docker Compose with two services: a service called `servant` and a
service called `database`. The latter is the default Postgres image from
DockerHub, but I wrote a custom `init.db` script that populates it with a schema
and dataset of random information from the Mega Man video game. I'll use this
data to write queries that will modify and read an actual database.

The [Servant Documentation](https://docs.servant.dev/en/latest/index.html) does
mention that there is a Stack template, but I wanted to start from scratch to
better understand everything. I simply created a new stack project with `stack
--init` with the bare template.

# A Simple API
We will start with a simple query that does no filtering. Looks like they
recommend that we put our API into it's own Haskell module. I created a new
module called `WebAPIType` which will contain the web API. Servant's whole bag
is the specification of the API at the type level. So this module will contain
that type or several types. Since we are working at the type level it makes
sense that we need language extensions:

```.haskell
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}
```

I'll start by creating a single query for pulling all the Mega Man games which
has the following schema:

```.sql
CREATE TABLE IF NOT EXISTS games (
  game_id           BIGSERIAL PRIMARY KEY,
  slug              TEXT NOT NULL UNIQUE CHECK (is_valid_slug(slug)),
  title             TEXT NOT NULL,
  series_number     SMALLINT CHECK (series_number > 0),
  release_date      DATE,
  platform          TEXT,               -- e.g., "NES", "SNES", "PS4"
  created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

We can define the `Game` record as follows:

```.haskell
type Date = UTCTime

data Game = Game {
    title :: Text,
    seriesNumber :: Integer,
    releaseDate :: Date,
    platform :: Text
}
```
This can easily be encoded and decoded from JSON which Servant takes care of for
us. Since we are using `Text` and `UTCTime` we also need the following imports:

```.haskell
import Servant.API
import Data.Time (UTCTime)
import Data.Text (Text)
```

Now using the `Game` record we define the `GameAPI` type as follows:

```.haskell
type GameAPI = "games" :> Get '[JSON] [Game]
```
Let's break this type's definition down:

- `"games"` is the name of our query.
- `:>` is a Servant operator that we use to create path in our API queries. We
  can think of `:>` as simply `/` where the last element in the chain of `:>`'s
  is the operation at that path. So `"games" :> Get '[JSON] [Game]` is
  equivalent to the path `/games` and it performs a `Get`, but if I did `"seg1"
  :> "seg2" :> "seg3" :> Get '[JSON] [b]` then we obtain a path `/seg1/seg2/se3`
  which will perform a `Get`. 
- `Get a b` describes the type of request being made at the path we describe
  using `:>`. This is a GET request and it'll return a `b` encoded as an `a`. So
  if `a` is `'[JSON]`, then `b` is encoded as a JSON response using 
  [Aeson](https://hackage.haskell.org/package/aeson).

  Next we need to actually serve the API. We'll create a new module called
  `Server` for this. First, we import the `WebAPI`:

  ```.haskell
  import WebAPIType (GameAPI, Game)
  ```

Then from Servant we will need the following:

```.haskell
import Servant (Server, Application, Proxy(..), serve)
```

`Server` is the type of the server that we will create from our API `GameAPI`.
It is here that we connect the API to our server-side resolver (Servant calls
these handlers). It has the following definition:

```.haskell
class HasServer api context where
  type ServerT api (m :: Type -> Type) :: Type

  route ::
       Proxy api
    -> Context context
    -> Delayed env (Server api)
    -> Router env

  hoistServerWithContext
      :: Proxy api
      -> Proxy context
      -> (forall x. m x -> n x)
      -> ServerT api m
      -> ServerT api n

type Server api = ServerT api Handler
```

This is a cool way to define the `Server` type, using a type class, because now
Servant can create different instances based on how the API is defined. For
example, if one of your endpoints in your API route requires input, then Servant
will require your resolver to be a function where the input is this input to the
route. We will see some examples of this later.

The `Proxy` type is used to create a witness to all our type-level magic. We
give the proxied API to the `serve` command when we create our final Servant
`Application`. This application can then be given to the Wai Warp server which
allows us to actually serve our API on a port of our system.

The `GameAPI` can now be turned into something servable using the above:

```.haskell
games :: [Game]
games = []

serverGames :: Server GameAPI
serverGames = return games

-- Actually build the api:
gamesAPI :: Proxy GameAPI
gamesAPI = Proxy

gamesApp :: Application
gamesApp = serve gamesAPI serverGames
```

One question I currently have is, can `games` exist in the IO monad? I'll need
to query the database which will need to be in IO.

Finally, we can serve our API using the following:

```.haskell
module Main (main) where

import Server (gamesApp)

import Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 5000 gamesApp
```

Let's try and get this connected to the database using the [HASQL Library](https://hackage.haskell.org/package/hasql).

## The Database

[HASQL Library](https://hackage.haskell.org/package/hasql) appears to be the
best option for connecting to Postgres that is production grade. In this section
we will setup HASQL within our example Servant application. This will allow us
to conduct more realistic experiments to help our understanding.

Getting HASQL installed was a little bit of a challenge, because I didn't want
to install the full Postgres database in the container of our example API,
because it runs in a separate container as its own service. So I just want to
connect to it using HASQL as a client. This requires the following packages be
installed in the API's container:

```
- libpq-dev
- postgresql-client
```

These got HASQL to fully install as part of our project. I also needed to add
the following dependencies to my `stack.yaml`'s `extra-deps`:

```
- testcontainers
- testcontainers-postgresql
- text-builder-core
- text-builder
```

HASQL wouldn't compile without them. Now that I have a working build we can
proceed with setting up HASQL to query my database. I created a new module
`Database` to house all of our database specific code. 

First, we have to establish a connection with the database. Based on the
documentation we should use these:

```.haskell
Hasql.Connection
Hasql.Connection.Setting
Hasql.Connection.Setting.Connection
```

I setup a database settings record:

```.haskell
data ConnectionSettings = ConnectionSettings {
    ipAddr :: String,
    port :: Int,
    user :: String,
    dbname :: String
}

settings :: ConnectionSettings
settings = ConnectionSettings {
    ipAddr = "123.4.5.6",
    port = 5432,
    user = "postgres",
    dbname = "postgres"
}
```

Then we can establish a connection to the database using `Connection.acquire ::
[Setting] -> IO (Either ConnectionError Connection)` where we first define a
`Setting` as a Postgres connection string:

```.haskell
psqlSettings :: T.Text
psqlSettings = T.pack $ "host="++settings.ipAddr++" dbname="++settings.dbname++" user="++settings.user++" port="++(show settings.port)

connect :: IO (Either Connection.ConnectionError Connection.Connection)
connect = Connection.acquire [connectSettings]
    where
        connectSettings = ConnectionSetting.connection $ ConnectionSettingConnection.string psqlSettings
```

Updating the main loop to make a connection to the database is pretty easy now:

```.haskell
main :: IO ()
main = do
    _dbcon <- connect
    case _dbcon of
        Left err -> putStrLn . show $ err
        Right dbcon -> do putStrLn "Connected to Postgres"
                          hFlush stdout
                          -- Make use of dbcon.
                          run 5000 gamesApp
```

In order to pass the database connection to `gamesApp`, we modify the type of
`gamesApp` placing it into the `Control.Monad.Reader` monad.

```.haskell
gamesApp :: Reader Connection Application
gamesApp = do
    sg <- serverGames
    return $ serve gamesAPI sg
```

Since the resolution of the query happens in `serverGames` we update it as well:

```.haskell
serverGames :: Reader Connection (Server GameAPI)
serverGames = do
    dbconn <- ask
    return . liftIO $ games dbconn
```

The type of `gamesProxy` doesn't need to change, because it does'nt need to
access the database. However, `games` is the resolution function, and hence does
need access to the database, but we update it as a pure function:

```.haskell
games :: Connection -> IO [Game]
games dbconn = return []
```

We now have access to the database in the resolution function for the `games`
query. So the next step is to actually write an SQL query for all of the games
in the database, and execute the query on the database using `dbconn`. 

To be continued....

# Authorization (TBA)

Authorization uses [Basic Auth](https://en.wikipedia.org/wiki/Basic_access_authentication)